{
  "name": "number-scrubber",
  "type": "registry:ui",
  "description": "",
  "registryDependencies": [
    "input"
  ],
  "files": [
    {
      "path": "ui/number-scrubber.tsx",
      "content": "import * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Input } from \"@/components/ui/input\";\n\nexport interface NumericScrubberProps\n  extends Omit<React.HTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  /**\n   * Current numeric value\n   */\n  value: number;\n  /**\n   * Callback whenever the value changes\n   */\n  onChange: (value: number) => void;\n  /**\n   * Minimum allowable value (clamped)\n   */\n  min?: number;\n  /**\n   * Maximum allowable value (clamped)\n   */\n  max?: number;\n  /**\n   * Step for increments (e.g., 1, 0.1, etc.)\n   */\n  step?: number;\n  /**\n   * Additional class names for the outer wrapper\n   */\n  className?: string;\n\n  /**\n   * Controls the number of pixels required to increase/decrease a step.\n   * A value of 1.0 means 1 pixel per step; 0.1 means 10 pixels per step\n   *\n   * * For fine-grained control (like opacity: 0-1): use a small value like 0.001\n   * * For medium control (like rotation: 0-360): use a medium value like 0.1\n   * * For coarse control (like integer counts): use a larger value like 0.5\n   */\n  scrubSensitivity?: number;\n}\n\nexport const NumericScrubber = React.forwardRef<\n  HTMLInputElement,\n  NumericScrubberProps\n>(\n  (\n    {\n      value,\n      onChange,\n      min = 0,\n      max = 100,\n      step = 1,\n      className,\n      scrubSensitivity = 0.5,\n      ...rest\n    },\n    ref\n  ) => {\n    // Internal state\n    const [internalValue, setInternalValue] = React.useState<number>(value);\n\n    // Refs to track dragging\n    const isDraggingRef = React.useRef(false);\n    const initialXRef = React.useRef(0);\n    const initialValueRef = React.useRef(value);\n\n    // Determine how many decimals to keep based on `step`\n    const decimals = React.useMemo(() => {\n      if (!Number.isFinite(step)) return 0;\n      const stepString = step.toString();\n      const decimalPart = stepString.split(\".\")[1];\n      return decimalPart ? decimalPart.length : 0;\n    }, [step]);\n\n    /**\n     * Clamp and quantize the given number\n     */\n    function clampAndQuantize(n: number) {\n      // First quantize to nearest step\n      const quantized = Math.round(n / step) * step;\n      // Then clamp between min and max\n      const clamped = Math.max(min, Math.min(quantized, max));\n      return parseFloat(clamped.toFixed(decimals));\n    }\n\n    /**\n     * On pointer down: start dragging\n     */\n    function handlePointerDown(e: React.PointerEvent) {\n      // Only left-click\n      if (e.button !== 0) return;\n\n      isDraggingRef.current = true;\n      initialXRef.current = e.clientX;\n      initialValueRef.current = internalValue;\n\n      document.addEventListener(\"pointermove\", handlePointerMove);\n      document.addEventListener(\"pointerup\", handlePointerUp);\n    }\n\n    /**\n     * On pointer move: compute distance from initial pointer down\n     * and update value accordingly\n     */\n    function handlePointerMove(e: PointerEvent) {\n      if (!isDraggingRef.current) return;\n\n      const deltaX = e.clientX - initialXRef.current;\n      // Apply sensitivity factor to make scrubbing slower\n      let newValue = initialValueRef.current + deltaX * step * scrubSensitivity;\n      newValue = clampAndQuantize(newValue);\n\n      setInternalValue(newValue);\n      onChange(newValue);\n    }\n\n    /**\n     * On pointer up: stop dragging\n     */\n    function handlePointerUp() {\n      isDraggingRef.current = false;\n      document.removeEventListener(\"pointermove\", handlePointerMove);\n      document.removeEventListener(\"pointerup\", handlePointerUp);\n    }\n\n    /**\n     * When user types in the input\n     */\n    function handleInputChange(e: React.ChangeEvent<HTMLInputElement>) {\n      const inputVal = e.target.value;\n      if (inputVal === \"\") {\n        setInternalValue(min);\n        onChange(min);\n        return;\n      }\n\n      const parsed = parseFloat(inputVal);\n      if (isNaN(parsed)) {\n        setInternalValue(min);\n        onChange(min);\n        return;\n      }\n\n      const newValue = clampAndQuantize(parsed);\n      setInternalValue(newValue);\n      onChange(newValue);\n    }\n\n    /**\n     * Sync internalValue with external `value` if it changes\n     */\n    React.useEffect(() => {\n      setInternalValue(value);\n    }, [value]);\n\n    return (\n      <div className={cn(\"relative group w-fit\")}>\n        <Input\n          ref={ref}\n          type=\"number\"\n          /**\n           * Hide the default spinners in Chrome/Edge/Safari\n           */\n          className={cn(\n            `[appearance:textfield]\n             [&::-webkit-inner-spin-button]:appearance-none\n             [&::-webkit-outer-spin-button]:appearance-none\n             pr-0\n             hover:cursor-ew-resize\n             active:cursor-none\n             `,\n            className\n          )}\n          step={step}\n          value={internalValue}\n          onChange={handleInputChange}\n          onPointerDown={handlePointerDown}\n          {...rest}\n        />\n\n        <div\n          className=\"absolute inset-y-0 right-0 flex items-center px-2 text-gray-400 cursor-ew-resize select-none\"\n          onPointerDown={handlePointerDown}\n        >\n          â†”\n        </div>\n      </div>\n    );\n  }\n);\n\nNumericScrubber.displayName = \"NumericScrubber\";\n",
      "type": "registry:ui"
    }
  ]
}